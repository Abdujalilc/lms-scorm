//
// rollupConsiderationsType.cs.cs
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//


using System.Collections;
using System.Xml;
using Altova.Types;

namespace adlseq_v1p3
{
	public class rollupConsiderationsType : Altova.Node
	{
		#region Forward constructors
		public rollupConsiderationsType() : base() { SetCollectionParents(); }
		public rollupConsiderationsType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public rollupConsiderationsType(XmlNode node) : base(node) { SetCollectionParents(); }
		public rollupConsiderationsType(Altova.Node node) : base(node) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{
			int nCount;

			nCount = DomChildCount(NodeType.Attribute, "", "requiredForSatisfied");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "requiredForSatisfied", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "requiredForNotSatisfied");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "requiredForNotSatisfied", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "requiredForCompleted");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "requiredForCompleted", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "requiredForIncomplete");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "requiredForIncomplete", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "measureSatisfactionIfActive");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "measureSatisfactionIfActive", i);
				InternalAdjustPrefix(DOMNode, false);
			}
		}


		#region requiredForSatisfied accessor methods
		public int GetrequiredForSatisfiedMinCount()
		{
			return 0;
		}

		public int requiredForSatisfiedMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetrequiredForSatisfiedMaxCount()
		{
			return 1;
		}

		public int requiredForSatisfiedMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetrequiredForSatisfiedCount()
		{
			return DomChildCount(NodeType.Attribute, "", "requiredForSatisfied");
		}

		public int requiredForSatisfiedCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "requiredForSatisfied");
			}
		}

		public bool HasrequiredForSatisfied()
		{
			return HasDomChild(NodeType.Attribute, "", "requiredForSatisfied");
		}

		public rollupConsiderationType GetrequiredForSatisfiedAt(int index)
		{
			return new rollupConsiderationType(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "requiredForSatisfied", index)));
		}

		public rollupConsiderationType GetrequiredForSatisfied()
		{
			return GetrequiredForSatisfiedAt(0);
		}

		public rollupConsiderationType requiredForSatisfied
		{
			get
			{
				return GetrequiredForSatisfiedAt(0);
			}
		}

		public void RemoverequiredForSatisfiedAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "requiredForSatisfied", index);
		}

		public void RemoverequiredForSatisfied()
		{
			while (HasrequiredForSatisfied())
				RemoverequiredForSatisfiedAt(0);
		}

		public void AddrequiredForSatisfied(rollupConsiderationType newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "requiredForSatisfied", newValue.ToString());
		}

		public void InsertrequiredForSatisfiedAt(rollupConsiderationType newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "requiredForSatisfied", index, newValue.ToString());
		}

		public void ReplacerequiredForSatisfiedAt(rollupConsiderationType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "requiredForSatisfied", index, newValue.ToString());
		}
		#endregion // requiredForSatisfied accessor methods

		#region requiredForSatisfied collection
        public requiredForSatisfiedCollection	MyrequiredForSatisfieds = new requiredForSatisfiedCollection( );

        public class requiredForSatisfiedCollection: IEnumerable
        {
            rollupConsiderationsType parent;
            public rollupConsiderationsType Parent
			{
				set
				{
					parent = value;
				}
			}
			public requiredForSatisfiedEnumerator GetEnumerator() 
			{
				return new requiredForSatisfiedEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class requiredForSatisfiedEnumerator: IEnumerator 
        {
			int nIndex;
			rollupConsiderationsType parent;
			public requiredForSatisfiedEnumerator(rollupConsiderationsType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.requiredForSatisfiedCount );
			}
			public rollupConsiderationType  Current 
			{
				get 
				{
					return(parent.GetrequiredForSatisfiedAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // requiredForSatisfied collection

		#region requiredForNotSatisfied accessor methods
		public int GetrequiredForNotSatisfiedMinCount()
		{
			return 0;
		}

		public int requiredForNotSatisfiedMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetrequiredForNotSatisfiedMaxCount()
		{
			return 1;
		}

		public int requiredForNotSatisfiedMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetrequiredForNotSatisfiedCount()
		{
			return DomChildCount(NodeType.Attribute, "", "requiredForNotSatisfied");
		}

		public int requiredForNotSatisfiedCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "requiredForNotSatisfied");
			}
		}

		public bool HasrequiredForNotSatisfied()
		{
			return HasDomChild(NodeType.Attribute, "", "requiredForNotSatisfied");
		}

		public rollupConsiderationType GetrequiredForNotSatisfiedAt(int index)
		{
			return new rollupConsiderationType(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "requiredForNotSatisfied", index)));
		}

		public rollupConsiderationType GetrequiredForNotSatisfied()
		{
			return GetrequiredForNotSatisfiedAt(0);
		}

		public rollupConsiderationType requiredForNotSatisfied
		{
			get
			{
				return GetrequiredForNotSatisfiedAt(0);
			}
		}

		public void RemoverequiredForNotSatisfiedAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "requiredForNotSatisfied", index);
		}

		public void RemoverequiredForNotSatisfied()
		{
			while (HasrequiredForNotSatisfied())
				RemoverequiredForNotSatisfiedAt(0);
		}

		public void AddrequiredForNotSatisfied(rollupConsiderationType newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "requiredForNotSatisfied", newValue.ToString());
		}

		public void InsertrequiredForNotSatisfiedAt(rollupConsiderationType newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "requiredForNotSatisfied", index, newValue.ToString());
		}

		public void ReplacerequiredForNotSatisfiedAt(rollupConsiderationType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "requiredForNotSatisfied", index, newValue.ToString());
		}
		#endregion // requiredForNotSatisfied accessor methods

		#region requiredForNotSatisfied collection
        public requiredForNotSatisfiedCollection	MyrequiredForNotSatisfieds = new requiredForNotSatisfiedCollection( );

        public class requiredForNotSatisfiedCollection: IEnumerable
        {
            rollupConsiderationsType parent;
            public rollupConsiderationsType Parent
			{
				set
				{
					parent = value;
				}
			}
			public requiredForNotSatisfiedEnumerator GetEnumerator() 
			{
				return new requiredForNotSatisfiedEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class requiredForNotSatisfiedEnumerator: IEnumerator 
        {
			int nIndex;
			rollupConsiderationsType parent;
			public requiredForNotSatisfiedEnumerator(rollupConsiderationsType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.requiredForNotSatisfiedCount );
			}
			public rollupConsiderationType  Current 
			{
				get 
				{
					return(parent.GetrequiredForNotSatisfiedAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // requiredForNotSatisfied collection

		#region requiredForCompleted accessor methods
		public int GetrequiredForCompletedMinCount()
		{
			return 0;
		}

		public int requiredForCompletedMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetrequiredForCompletedMaxCount()
		{
			return 1;
		}

		public int requiredForCompletedMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetrequiredForCompletedCount()
		{
			return DomChildCount(NodeType.Attribute, "", "requiredForCompleted");
		}

		public int requiredForCompletedCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "requiredForCompleted");
			}
		}

		public bool HasrequiredForCompleted()
		{
			return HasDomChild(NodeType.Attribute, "", "requiredForCompleted");
		}

		public rollupConsiderationType GetrequiredForCompletedAt(int index)
		{
			return new rollupConsiderationType(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "requiredForCompleted", index)));
		}

		public rollupConsiderationType GetrequiredForCompleted()
		{
			return GetrequiredForCompletedAt(0);
		}

		public rollupConsiderationType requiredForCompleted
		{
			get
			{
				return GetrequiredForCompletedAt(0);
			}
		}

		public void RemoverequiredForCompletedAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "requiredForCompleted", index);
		}

		public void RemoverequiredForCompleted()
		{
			while (HasrequiredForCompleted())
				RemoverequiredForCompletedAt(0);
		}

		public void AddrequiredForCompleted(rollupConsiderationType newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "requiredForCompleted", newValue.ToString());
		}

		public void InsertrequiredForCompletedAt(rollupConsiderationType newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "requiredForCompleted", index, newValue.ToString());
		}

		public void ReplacerequiredForCompletedAt(rollupConsiderationType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "requiredForCompleted", index, newValue.ToString());
		}
		#endregion // requiredForCompleted accessor methods

		#region requiredForCompleted collection
        public requiredForCompletedCollection	MyrequiredForCompleteds = new requiredForCompletedCollection( );

        public class requiredForCompletedCollection: IEnumerable
        {
            rollupConsiderationsType parent;
            public rollupConsiderationsType Parent
			{
				set
				{
					parent = value;
				}
			}
			public requiredForCompletedEnumerator GetEnumerator() 
			{
				return new requiredForCompletedEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class requiredForCompletedEnumerator: IEnumerator 
        {
			int nIndex;
			rollupConsiderationsType parent;
			public requiredForCompletedEnumerator(rollupConsiderationsType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.requiredForCompletedCount );
			}
			public rollupConsiderationType  Current 
			{
				get 
				{
					return(parent.GetrequiredForCompletedAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // requiredForCompleted collection

		#region requiredForIncomplete accessor methods
		public int GetrequiredForIncompleteMinCount()
		{
			return 0;
		}

		public int requiredForIncompleteMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetrequiredForIncompleteMaxCount()
		{
			return 1;
		}

		public int requiredForIncompleteMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetrequiredForIncompleteCount()
		{
			return DomChildCount(NodeType.Attribute, "", "requiredForIncomplete");
		}

		public int requiredForIncompleteCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "requiredForIncomplete");
			}
		}

		public bool HasrequiredForIncomplete()
		{
			return HasDomChild(NodeType.Attribute, "", "requiredForIncomplete");
		}

		public rollupConsiderationType GetrequiredForIncompleteAt(int index)
		{
			return new rollupConsiderationType(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "requiredForIncomplete", index)));
		}

		public rollupConsiderationType GetrequiredForIncomplete()
		{
			return GetrequiredForIncompleteAt(0);
		}

		public rollupConsiderationType requiredForIncomplete
		{
			get
			{
				return GetrequiredForIncompleteAt(0);
			}
		}

		public void RemoverequiredForIncompleteAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "requiredForIncomplete", index);
		}

		public void RemoverequiredForIncomplete()
		{
			while (HasrequiredForIncomplete())
				RemoverequiredForIncompleteAt(0);
		}

		public void AddrequiredForIncomplete(rollupConsiderationType newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "requiredForIncomplete", newValue.ToString());
		}

		public void InsertrequiredForIncompleteAt(rollupConsiderationType newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "requiredForIncomplete", index, newValue.ToString());
		}

		public void ReplacerequiredForIncompleteAt(rollupConsiderationType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "requiredForIncomplete", index, newValue.ToString());
		}
		#endregion // requiredForIncomplete accessor methods

		#region requiredForIncomplete collection
        public requiredForIncompleteCollection	MyrequiredForIncompletes = new requiredForIncompleteCollection( );

        public class requiredForIncompleteCollection: IEnumerable
        {
            rollupConsiderationsType parent;
            public rollupConsiderationsType Parent
			{
				set
				{
					parent = value;
				}
			}
			public requiredForIncompleteEnumerator GetEnumerator() 
			{
				return new requiredForIncompleteEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class requiredForIncompleteEnumerator: IEnumerator 
        {
			int nIndex;
			rollupConsiderationsType parent;
			public requiredForIncompleteEnumerator(rollupConsiderationsType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.requiredForIncompleteCount );
			}
			public rollupConsiderationType  Current 
			{
				get 
				{
					return(parent.GetrequiredForIncompleteAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // requiredForIncomplete collection

		#region measureSatisfactionIfActive accessor methods
		public int GetmeasureSatisfactionIfActiveMinCount()
		{
			return 0;
		}

		public int measureSatisfactionIfActiveMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetmeasureSatisfactionIfActiveMaxCount()
		{
			return 1;
		}

		public int measureSatisfactionIfActiveMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetmeasureSatisfactionIfActiveCount()
		{
			return DomChildCount(NodeType.Attribute, "", "measureSatisfactionIfActive");
		}

		public int measureSatisfactionIfActiveCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "measureSatisfactionIfActive");
			}
		}

		public bool HasmeasureSatisfactionIfActive()
		{
			return HasDomChild(NodeType.Attribute, "", "measureSatisfactionIfActive");
		}

		public SchemaBoolean GetmeasureSatisfactionIfActiveAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "measureSatisfactionIfActive", index)));
		}

		public SchemaBoolean GetmeasureSatisfactionIfActive()
		{
			return GetmeasureSatisfactionIfActiveAt(0);
		}

		public SchemaBoolean measureSatisfactionIfActive
		{
			get
			{
				return GetmeasureSatisfactionIfActiveAt(0);
			}
		}

		public void RemovemeasureSatisfactionIfActiveAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "measureSatisfactionIfActive", index);
		}

		public void RemovemeasureSatisfactionIfActive()
		{
			while (HasmeasureSatisfactionIfActive())
				RemovemeasureSatisfactionIfActiveAt(0);
		}

		public void AddmeasureSatisfactionIfActive(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "measureSatisfactionIfActive", newValue.ToString());
		}

		public void InsertmeasureSatisfactionIfActiveAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "measureSatisfactionIfActive", index, newValue.ToString());
		}

		public void ReplacemeasureSatisfactionIfActiveAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "measureSatisfactionIfActive", index, newValue.ToString());
		}
		#endregion // measureSatisfactionIfActive accessor methods

		#region measureSatisfactionIfActive collection
        public measureSatisfactionIfActiveCollection	MymeasureSatisfactionIfActives = new measureSatisfactionIfActiveCollection( );

        public class measureSatisfactionIfActiveCollection: IEnumerable
        {
            rollupConsiderationsType parent;
            public rollupConsiderationsType Parent
			{
				set
				{
					parent = value;
				}
			}
			public measureSatisfactionIfActiveEnumerator GetEnumerator() 
			{
				return new measureSatisfactionIfActiveEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class measureSatisfactionIfActiveEnumerator: IEnumerator 
        {
			int nIndex;
			rollupConsiderationsType parent;
			public measureSatisfactionIfActiveEnumerator(rollupConsiderationsType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.measureSatisfactionIfActiveCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetmeasureSatisfactionIfActiveAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // measureSatisfactionIfActive collection

        private void SetCollectionParents()
        {
            MyrequiredForSatisfieds.Parent = this; 
            MyrequiredForNotSatisfieds.Parent = this; 
            MyrequiredForCompleteds.Parent = this; 
            MyrequiredForIncompletes.Parent = this; 
            MymeasureSatisfactionIfActives.Parent = this; 
	}
}
}
