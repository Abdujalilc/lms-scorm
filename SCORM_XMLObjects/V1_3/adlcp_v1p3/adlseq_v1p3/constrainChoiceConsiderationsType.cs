//
// constrainChoiceConsiderationsType.cs.cs
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//


using System.Collections;
using System.Xml;
using Altova.Types;

namespace adlseq_v1p3
{
	public class constrainChoiceConsiderationsType : Altova.Node
	{
		#region Forward constructors
		public constrainChoiceConsiderationsType() : base() { SetCollectionParents(); }
		public constrainChoiceConsiderationsType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public constrainChoiceConsiderationsType(XmlNode node) : base(node) { SetCollectionParents(); }
		public constrainChoiceConsiderationsType(Altova.Node node) : base(node) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{
			int nCount;

			nCount = DomChildCount(NodeType.Attribute, "", "preventActivation");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "preventActivation", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "constrainChoice");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "constrainChoice", i);
				InternalAdjustPrefix(DOMNode, false);
			}
		}


		#region preventActivation accessor methods
		public int GetpreventActivationMinCount()
		{
			return 0;
		}

		public int preventActivationMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetpreventActivationMaxCount()
		{
			return 1;
		}

		public int preventActivationMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetpreventActivationCount()
		{
			return DomChildCount(NodeType.Attribute, "", "preventActivation");
		}

		public int preventActivationCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "preventActivation");
			}
		}

		public bool HaspreventActivation()
		{
			return HasDomChild(NodeType.Attribute, "", "preventActivation");
		}

		public SchemaBoolean GetpreventActivationAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "preventActivation", index)));
		}

		public SchemaBoolean GetpreventActivation()
		{
			return GetpreventActivationAt(0);
		}

		public SchemaBoolean preventActivation
		{
			get
			{
				return GetpreventActivationAt(0);
			}
		}

		public void RemovepreventActivationAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "preventActivation", index);
		}

		public void RemovepreventActivation()
		{
			while (HaspreventActivation())
				RemovepreventActivationAt(0);
		}

		public void AddpreventActivation(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "preventActivation", newValue.ToString());
		}

		public void InsertpreventActivationAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "preventActivation", index, newValue.ToString());
		}

		public void ReplacepreventActivationAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "preventActivation", index, newValue.ToString());
		}
		#endregion // preventActivation accessor methods

		#region preventActivation collection
        public preventActivationCollection	MypreventActivations = new preventActivationCollection( );

        public class preventActivationCollection: IEnumerable
        {
            constrainChoiceConsiderationsType parent;
            public constrainChoiceConsiderationsType Parent
			{
				set
				{
					parent = value;
				}
			}
			public preventActivationEnumerator GetEnumerator() 
			{
				return new preventActivationEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class preventActivationEnumerator: IEnumerator 
        {
			int nIndex;
			constrainChoiceConsiderationsType parent;
			public preventActivationEnumerator(constrainChoiceConsiderationsType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.preventActivationCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetpreventActivationAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // preventActivation collection

		#region constrainChoice accessor methods
		public int GetconstrainChoiceMinCount()
		{
			return 0;
		}

		public int constrainChoiceMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetconstrainChoiceMaxCount()
		{
			return 1;
		}

		public int constrainChoiceMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetconstrainChoiceCount()
		{
			return DomChildCount(NodeType.Attribute, "", "constrainChoice");
		}

		public int constrainChoiceCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "constrainChoice");
			}
		}

		public bool HasconstrainChoice()
		{
			return HasDomChild(NodeType.Attribute, "", "constrainChoice");
		}

		public SchemaBoolean GetconstrainChoiceAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "constrainChoice", index)));
		}

		public SchemaBoolean GetconstrainChoice()
		{
			return GetconstrainChoiceAt(0);
		}

		public SchemaBoolean constrainChoice
		{
			get
			{
				return GetconstrainChoiceAt(0);
			}
		}

		public void RemoveconstrainChoiceAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "constrainChoice", index);
		}

		public void RemoveconstrainChoice()
		{
			while (HasconstrainChoice())
				RemoveconstrainChoiceAt(0);
		}

		public void AddconstrainChoice(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "constrainChoice", newValue.ToString());
		}

		public void InsertconstrainChoiceAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "constrainChoice", index, newValue.ToString());
		}

		public void ReplaceconstrainChoiceAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "constrainChoice", index, newValue.ToString());
		}
		#endregion // constrainChoice accessor methods

		#region constrainChoice collection
        public constrainChoiceCollection	MyconstrainChoices = new constrainChoiceCollection( );

        public class constrainChoiceCollection: IEnumerable
        {
            constrainChoiceConsiderationsType parent;
            public constrainChoiceConsiderationsType Parent
			{
				set
				{
					parent = value;
				}
			}
			public constrainChoiceEnumerator GetEnumerator() 
			{
				return new constrainChoiceEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class constrainChoiceEnumerator: IEnumerator 
        {
			int nIndex;
			constrainChoiceConsiderationsType parent;
			public constrainChoiceEnumerator(constrainChoiceConsiderationsType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.constrainChoiceCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetconstrainChoiceAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // constrainChoice collection

        private void SetCollectionParents()
        {
            MypreventActivations.Parent = this; 
            MyconstrainChoices.Parent = this; 
	}
}
}
