//
// controlModeType.cs.cs
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//


using System.Collections;
using System.Xml;
using Altova.Types;

namespace imsss_v1p0
{
	public class controlModeType : Altova.Node
	{
		#region Forward constructors
		public controlModeType() : base() { SetCollectionParents(); }
		public controlModeType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public controlModeType(XmlNode node) : base(node) { SetCollectionParents(); }
		public controlModeType(Altova.Node node) : base(node) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{
			int nCount;

			nCount = DomChildCount(NodeType.Attribute, "", "choice");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "choice", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "choiceExit");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "choiceExit", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "flow");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "flow", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "forwardOnly");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "forwardOnly", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			nCount = DomChildCount(NodeType.Attribute, "", "useCurrentAttemptProgressInfo");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "useCurrentAttemptProgressInfo", i);
				InternalAdjustPrefix(DOMNode, false);
			}
		}


		#region choice accessor methods
		public int GetchoiceMinCount()
		{
			return 0;
		}

		public int choiceMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetchoiceMaxCount()
		{
			return 1;
		}

		public int choiceMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetchoiceCount()
		{
			return DomChildCount(NodeType.Attribute, "", "choice");
		}

		public int choiceCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "choice");
			}
		}

		public bool Haschoice()
		{
			return HasDomChild(NodeType.Attribute, "", "choice");
		}

		public SchemaBoolean GetchoiceAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "choice", index)));
		}

		public SchemaBoolean Getchoice()
		{
			return GetchoiceAt(0);
		}

		public SchemaBoolean choice
		{
			get
			{
				return GetchoiceAt(0);
			}
		}

		public void RemovechoiceAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "choice", index);
		}

		public void Removechoice()
		{
			while (Haschoice())
				RemovechoiceAt(0);
		}

		public void Addchoice(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "choice", newValue.ToString());
		}

		public void InsertchoiceAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "choice", index, newValue.ToString());
		}

		public void ReplacechoiceAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "choice", index, newValue.ToString());
		}
		#endregion // choice accessor methods

		#region choice collection
        public choiceCollection	Mychoices = new choiceCollection( );

        public class choiceCollection: IEnumerable
        {
            controlModeType parent;
            public controlModeType Parent
			{
				set
				{
					parent = value;
				}
			}
			public choiceEnumerator GetEnumerator() 
			{
				return new choiceEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class choiceEnumerator: IEnumerator 
        {
			int nIndex;
			controlModeType parent;
			public choiceEnumerator(controlModeType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.choiceCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetchoiceAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // choice collection

		#region choiceExit accessor methods
		public int GetchoiceExitMinCount()
		{
			return 0;
		}

		public int choiceExitMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetchoiceExitMaxCount()
		{
			return 1;
		}

		public int choiceExitMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetchoiceExitCount()
		{
			return DomChildCount(NodeType.Attribute, "", "choiceExit");
		}

		public int choiceExitCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "choiceExit");
			}
		}

		public bool HaschoiceExit()
		{
			return HasDomChild(NodeType.Attribute, "", "choiceExit");
		}

		public SchemaBoolean GetchoiceExitAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "choiceExit", index)));
		}

		public SchemaBoolean GetchoiceExit()
		{
			return GetchoiceExitAt(0);
		}

		public SchemaBoolean choiceExit
		{
			get
			{
				return GetchoiceExitAt(0);
			}
		}

		public void RemovechoiceExitAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "choiceExit", index);
		}

		public void RemovechoiceExit()
		{
			while (HaschoiceExit())
				RemovechoiceExitAt(0);
		}

		public void AddchoiceExit(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "choiceExit", newValue.ToString());
		}

		public void InsertchoiceExitAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "choiceExit", index, newValue.ToString());
		}

		public void ReplacechoiceExitAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "choiceExit", index, newValue.ToString());
		}
		#endregion // choiceExit accessor methods

		#region choiceExit collection
        public choiceExitCollection	MychoiceExits = new choiceExitCollection( );

        public class choiceExitCollection: IEnumerable
        {
            controlModeType parent;
            public controlModeType Parent
			{
				set
				{
					parent = value;
				}
			}
			public choiceExitEnumerator GetEnumerator() 
			{
				return new choiceExitEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class choiceExitEnumerator: IEnumerator 
        {
			int nIndex;
			controlModeType parent;
			public choiceExitEnumerator(controlModeType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.choiceExitCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetchoiceExitAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // choiceExit collection

		#region flow accessor methods
		public int GetflowMinCount()
		{
			return 0;
		}

		public int flowMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetflowMaxCount()
		{
			return 1;
		}

		public int flowMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetflowCount()
		{
			return DomChildCount(NodeType.Attribute, "", "flow");
		}

		public int flowCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "flow");
			}
		}

		public bool Hasflow()
		{
			return HasDomChild(NodeType.Attribute, "", "flow");
		}

		public SchemaBoolean GetflowAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "flow", index)));
		}

		public SchemaBoolean Getflow()
		{
			return GetflowAt(0);
		}

		public SchemaBoolean flow
		{
			get
			{
				return GetflowAt(0);
			}
		}

		public void RemoveflowAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "flow", index);
		}

		public void Removeflow()
		{
			while (Hasflow())
				RemoveflowAt(0);
		}

		public void Addflow(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "flow", newValue.ToString());
		}

		public void InsertflowAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "flow", index, newValue.ToString());
		}

		public void ReplaceflowAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "flow", index, newValue.ToString());
		}
		#endregion // flow accessor methods

		#region flow collection
        public flowCollection	Myflows = new flowCollection( );

        public class flowCollection: IEnumerable
        {
            controlModeType parent;
            public controlModeType Parent
			{
				set
				{
					parent = value;
				}
			}
			public flowEnumerator GetEnumerator() 
			{
				return new flowEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class flowEnumerator: IEnumerator 
        {
			int nIndex;
			controlModeType parent;
			public flowEnumerator(controlModeType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.flowCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetflowAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // flow collection

		#region forwardOnly accessor methods
		public int GetforwardOnlyMinCount()
		{
			return 0;
		}

		public int forwardOnlyMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetforwardOnlyMaxCount()
		{
			return 1;
		}

		public int forwardOnlyMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetforwardOnlyCount()
		{
			return DomChildCount(NodeType.Attribute, "", "forwardOnly");
		}

		public int forwardOnlyCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "forwardOnly");
			}
		}

		public bool HasforwardOnly()
		{
			return HasDomChild(NodeType.Attribute, "", "forwardOnly");
		}

		public SchemaBoolean GetforwardOnlyAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "forwardOnly", index)));
		}

		public SchemaBoolean GetforwardOnly()
		{
			return GetforwardOnlyAt(0);
		}

		public SchemaBoolean forwardOnly
		{
			get
			{
				return GetforwardOnlyAt(0);
			}
		}

		public void RemoveforwardOnlyAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "forwardOnly", index);
		}

		public void RemoveforwardOnly()
		{
			while (HasforwardOnly())
				RemoveforwardOnlyAt(0);
		}

		public void AddforwardOnly(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "forwardOnly", newValue.ToString());
		}

		public void InsertforwardOnlyAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "forwardOnly", index, newValue.ToString());
		}

		public void ReplaceforwardOnlyAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "forwardOnly", index, newValue.ToString());
		}
		#endregion // forwardOnly accessor methods

		#region forwardOnly collection
        public forwardOnlyCollection	MyforwardOnlys = new forwardOnlyCollection( );

        public class forwardOnlyCollection: IEnumerable
        {
            controlModeType parent;
            public controlModeType Parent
			{
				set
				{
					parent = value;
				}
			}
			public forwardOnlyEnumerator GetEnumerator() 
			{
				return new forwardOnlyEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class forwardOnlyEnumerator: IEnumerator 
        {
			int nIndex;
			controlModeType parent;
			public forwardOnlyEnumerator(controlModeType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.forwardOnlyCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetforwardOnlyAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // forwardOnly collection

		#region useCurrentAttemptObjectiveInfo accessor methods
		public int GetuseCurrentAttemptObjectiveInfoMinCount()
		{
			return 0;
		}

		public int useCurrentAttemptObjectiveInfoMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetuseCurrentAttemptObjectiveInfoMaxCount()
		{
			return 1;
		}

		public int useCurrentAttemptObjectiveInfoMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetuseCurrentAttemptObjectiveInfoCount()
		{
			return DomChildCount(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo");
		}

		public int useCurrentAttemptObjectiveInfoCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo");
			}
		}

		public bool HasuseCurrentAttemptObjectiveInfo()
		{
			return HasDomChild(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo");
		}

		public SchemaBoolean GetuseCurrentAttemptObjectiveInfoAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo", index)));
		}

		public SchemaBoolean GetuseCurrentAttemptObjectiveInfo()
		{
			return GetuseCurrentAttemptObjectiveInfoAt(0);
		}

		public SchemaBoolean useCurrentAttemptObjectiveInfo
		{
			get
			{
				return GetuseCurrentAttemptObjectiveInfoAt(0);
			}
		}

		public void RemoveuseCurrentAttemptObjectiveInfoAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo", index);
		}

		public void RemoveuseCurrentAttemptObjectiveInfo()
		{
			while (HasuseCurrentAttemptObjectiveInfo())
				RemoveuseCurrentAttemptObjectiveInfoAt(0);
		}

		public void AdduseCurrentAttemptObjectiveInfo(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo", newValue.ToString());
		}

		public void InsertuseCurrentAttemptObjectiveInfoAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo", index, newValue.ToString());
		}

		public void ReplaceuseCurrentAttemptObjectiveInfoAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "useCurrentAttemptObjectiveInfo", index, newValue.ToString());
		}
		#endregion // useCurrentAttemptObjectiveInfo accessor methods

		#region useCurrentAttemptObjectiveInfo collection
        public useCurrentAttemptObjectiveInfoCollection	MyuseCurrentAttemptObjectiveInfos = new useCurrentAttemptObjectiveInfoCollection( );

        public class useCurrentAttemptObjectiveInfoCollection: IEnumerable
        {
            controlModeType parent;
            public controlModeType Parent
			{
				set
				{
					parent = value;
				}
			}
			public useCurrentAttemptObjectiveInfoEnumerator GetEnumerator() 
			{
				return new useCurrentAttemptObjectiveInfoEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class useCurrentAttemptObjectiveInfoEnumerator: IEnumerator 
        {
			int nIndex;
			controlModeType parent;
			public useCurrentAttemptObjectiveInfoEnumerator(controlModeType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.useCurrentAttemptObjectiveInfoCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetuseCurrentAttemptObjectiveInfoAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // useCurrentAttemptObjectiveInfo collection

		#region useCurrentAttemptProgressInfo accessor methods
		public int GetuseCurrentAttemptProgressInfoMinCount()
		{
			return 0;
		}

		public int useCurrentAttemptProgressInfoMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetuseCurrentAttemptProgressInfoMaxCount()
		{
			return 1;
		}

		public int useCurrentAttemptProgressInfoMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetuseCurrentAttemptProgressInfoCount()
		{
			return DomChildCount(NodeType.Attribute, "", "useCurrentAttemptProgressInfo");
		}

		public int useCurrentAttemptProgressInfoCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "useCurrentAttemptProgressInfo");
			}
		}

		public bool HasuseCurrentAttemptProgressInfo()
		{
			return HasDomChild(NodeType.Attribute, "", "useCurrentAttemptProgressInfo");
		}

		public SchemaBoolean GetuseCurrentAttemptProgressInfoAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "useCurrentAttemptProgressInfo", index)));
		}

		public SchemaBoolean GetuseCurrentAttemptProgressInfo()
		{
			return GetuseCurrentAttemptProgressInfoAt(0);
		}

		public SchemaBoolean useCurrentAttemptProgressInfo
		{
			get
			{
				return GetuseCurrentAttemptProgressInfoAt(0);
			}
		}

		public void RemoveuseCurrentAttemptProgressInfoAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "useCurrentAttemptProgressInfo", index);
		}

		public void RemoveuseCurrentAttemptProgressInfo()
		{
			while (HasuseCurrentAttemptProgressInfo())
				RemoveuseCurrentAttemptProgressInfoAt(0);
		}

		public void AdduseCurrentAttemptProgressInfo(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "useCurrentAttemptProgressInfo", newValue.ToString());
		}

		public void InsertuseCurrentAttemptProgressInfoAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "useCurrentAttemptProgressInfo", index, newValue.ToString());
		}

		public void ReplaceuseCurrentAttemptProgressInfoAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "useCurrentAttemptProgressInfo", index, newValue.ToString());
		}
		#endregion // useCurrentAttemptProgressInfo accessor methods

		#region useCurrentAttemptProgressInfo collection
        public useCurrentAttemptProgressInfoCollection	MyuseCurrentAttemptProgressInfos = new useCurrentAttemptProgressInfoCollection( );

        public class useCurrentAttemptProgressInfoCollection: IEnumerable
        {
            controlModeType parent;
            public controlModeType Parent
			{
				set
				{
					parent = value;
				}
			}
			public useCurrentAttemptProgressInfoEnumerator GetEnumerator() 
			{
				return new useCurrentAttemptProgressInfoEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class useCurrentAttemptProgressInfoEnumerator: IEnumerator 
        {
			int nIndex;
			controlModeType parent;
			public useCurrentAttemptProgressInfoEnumerator(controlModeType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.useCurrentAttemptProgressInfoCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetuseCurrentAttemptProgressInfoAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // useCurrentAttemptProgressInfo collection

        private void SetCollectionParents()
        {
            Mychoices.Parent = this; 
            MychoiceExits.Parent = this; 
            Myflows.Parent = this; 
            MyforwardOnlys.Parent = this; 
            MyuseCurrentAttemptObjectiveInfos.Parent = this; 
            MyuseCurrentAttemptProgressInfos.Parent = this; 
	}
}
}
